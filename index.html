<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discrete Mathematics in Cryptography: Securing Text, Images, and Videos</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background: linear-gradient(to bottom, #f3f4f6, #ffffff); 
            position: relative; 
            margin: 0; 
            padding: 0; 
        }
        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: url('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" fill="none" stroke="%23e5e7eb" stroke-width="0.5" opacity="0.1"%3E%3Cpath d="M0 50h100M50 0v100M25 0v100M75 0v100M0 25h100M0 75h100"/%3E%3C/svg%3E');
            z-index: -1;
        }
        header {
            background: linear-gradient(135deg, #1e3a8a, #2dd4bf);
            color: white;
            padding: 1.5rem 0;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        .math-inline { display: inline; }
        .section-container { max-width: 1200px; margin: auto; padding: 2rem; }
        .card { 
            background: white; 
            border-radius: 12px; 
            padding: 2rem; 
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05); 
            margin-bottom: 2rem; 
            transition: transform 0.3s ease, box-shadow 0.3s ease; 
        }
        .card:hover { 
            transform: translateY(-5px); 
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1); 
        }
        .interactive-demo { 
            border: 1px solid #e5e7eb; 
            padding: 1.5rem; 
            border-radius: 12px; 
            background: #f9fafb; 
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.02); 
        }
        .step { 
            background: white; 
            border-radius: 12px; 
            padding: 1.5rem; 
            margin: 1rem 0; 
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); 
            border-left: 5px solid #1e3a8a; 
            transition: all 0.3s ease; 
        }
        .step:hover { 
            transform: translateY(-3px); 
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.08); 
        }
        .step h2 { 
            color: #1e3a8a; 
            font-size: 1.5rem; 
            font-weight: 600; 
            margin-bottom: 1rem; 
        }
        .input-group { margin: 1rem 0; }
        label { 
            display: block; 
            margin-bottom: 0.5rem; 
            font-weight: 600; 
            color: #4b5563; 
        }
        input[type="text"], input[type="number"], input[type="file"] { 
            width: 100%; 
            padding: 0.75rem; 
            border: 2px solid #d1d5db; 
            border-radius: 8px; 
            font-size: 1rem; 
            transition: border-color 0.3s ease, box-shadow 0.3s ease; 
        }
        input[type="text"]:focus, input[type="number"]:focus, input[type="file"]:focus { 
            outline: none; 
            border-color: #2dd4bf; 
            box-shadow: 0 0 0 3px rgba(45, 212, 191, 0.2); 
        }
        button { 
            background: linear-gradient(45deg, #1e3a8a, #3b82f6); 
            color: white; 
            border: none; 
            padding: 0.75rem 1.5rem; 
            border-radius: 8px; 
            cursor: pointer; 
            font-size: 1rem; 
            font-weight: 600; 
            transition: transform 0.3s ease, box-shadow 0.3s ease; 
            margin: 0.5rem; 
        }
        button:hover { 
            transform: scale(1.05); 
            box-shadow: 0 6px 15px rgba(30, 58, 138, 0.3); 
        }
        button:disabled { 
            background: #d1d5db; 
            cursor: not-allowed; 
            transform: none; 
            box-shadow: none; 
        }
        .result { 
            background: #f9fafb; 
            border: 1px solid #e5e7eb; 
            border-radius: 8px; 
            padding: 1rem; 
            margin: 1rem 0; 
            font-family: 'Courier New', monospace; 
            white-space: pre-wrap; 
            word-break: break-all; 
            animation: fadeIn 0.5s ease; 
        }
        @keyframes fadeIn { 
            from { opacity: 0; } 
            to { opacity: 1; } 
        }
        .math-step { 
            background: #eff6ff; 
            border-left: 4px solid #3b82f6; 
            padding: 1rem; 
            margin: 1rem 0; 
            border-radius: 0 8px 8px 0; 
        }
        .success { 
            background: #ecfdf5; 
            border-left: 4px solid #10b981; 
            color: #065f46; 
        }
        .warning { 
            background: #fefce8; 
            border: 1px solid #f59e0b; 
            color: #854d0e; 
            padding: 1rem; 
            border-radius: 8px; 
            margin: 1rem 0; 
        }
        .grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 1.5rem; 
            margin: 1.5rem 0; 
        }
        .progress-bar { 
            background: #d1d5db; 
            height: 8px; 
            border-radius: 4px; 
            margin: 1.5rem 0; 
            overflow: hidden; 
        }
        .progress-fill { 
            background: linear-gradient(45deg, #2dd4bf, #14b8a6); 
            height: 100%; 
            width: 0%; 
            transition: width 0.5s ease; 
        }
        .char-encoding, .pixel-encoding { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 0.75rem; 
            margin: 1rem 0; 
        }
        .char-box, .pixel-box { 
            background: #1e3a8a; 
            color: white; 
            padding: 0.5rem 1rem; 
            border-radius: 6px; 
            font-family: 'Courier New', monospace; 
            text-align: center; 
            min-width: 60px; 
            animation: fadeInUp 0.5s ease; 
        }
        .canvas-container {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .canvas-label {
            font-weight: 600;
            color: #4b5563;
        }
        @keyframes fadeInUp { 
            from { opacity: 0; transform: translateY(10px); } 
            to { opacity: 1; transform: translateY(0); } 
        }
        @media (max-width: 768px) { 
            .grid { grid-template-columns: 1fr; } 
            .section-container { padding: 1rem; } 
            header h1 { font-size: 1.75rem; } 
            header { padding: 1rem 0; } 
        }
        #introduction h2,
        #text-encryption h2,
        #image-encryption h2,
        #video-encryption h2,
        #advanced-constructions h2,
        #conclusion h2 {
            background: linear-gradient(135deg, #1e3a8a, #2dd4bf);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-size: 1.875rem;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <header class="bg-gradient-to-r from-blue-900 to-teal-400 text-white py-12 shadow-lg" aria-label="Page header">
        <div class="section-container text-center">
            <h1 class="text-5xl font-bold tracking-wide uppercase">Discrete Mathematics in Cryptography</h1>
        </div>
    </header>

    <main class="math-container">
        <!-- Introduction -->
        <section id="introduction" class="my-12 card">
            <h2>Introduction</h2>
            <p class="mt-4 text-gray-700 leading-relaxed">
                Cryptography transforms sensitive data—text messages, color images, or video streams—into secure, unreadable forms using the power of discrete mathematics. From military intelligence to everyday communication, algorithms like RSA and AES rely on prime numbers, modular arithmetic, Euler’s theorem, and finite fields to ensure privacy and authenticity. This webpage explores how these mathematical principles secure text, images, and videos in an accessible yet rigorous way, with interactive simulators to bring the concepts to life.
            </p>
        </section>

        <!-- Text Encryption -->
        <section id="text-encryption" class="my-12 card">
            <h2>Text Encryption with RSA</h2>
            <p class="mt-4 text-gray-700 leading-relaxed">
                Text encryption converts readable messages into secure ciphertext, protecting sensitive information like emails, passwords, or financial transactions. RSA, a cornerstone of public-key cryptography, leverages number theory to achieve robust security, widely used in secure communication protocols like HTTPS and SSH.
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">From Text to Numbers</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                Each character in a message is mapped to an integer using ASCII encoding (e.g., ‘A’ → 65, ‘a’ → 97, space → 32). To handle multiple characters efficiently, we group them into a single integer using base-256 encoding, treating each character as a "digit" in a base-256 number system:
                \[
                M = c_1 \cdot 256^{k-1} + c_2 \cdot 256^{k-2} + \dots + c_k \cdot 256^0
                \]
                where \( c_i \) is the ASCII code of the \( i \)-th character, and \( k \) is the block size, ensuring the resulting message \( M \) is less than the RSA modulus \( n \). This encoding is reversible, allowing perfect recovery of the original text.
            </p>
            <div class="math-step">
                <strong>Why Base-256?</strong> Each character’s ASCII value fits within a byte (8 bits, 0–255), making base-256 a natural choice for compact and efficient encoding.
            </div>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">RSA Mechanics</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                RSA relies on the mathematical difficulty of factoring large numbers. The algorithm involves:
            </p>
            <ol class="list-decimal ml-6 mt-2 text-gray-700">
                <li>Choose two large prime numbers \( p \) and \( q \), typically hundreds of digits long in practice.</li>
                <li>Compute the modulus \( n = p \cdot q \), which defines the range of numbers in the system.</li>
                <li>Calculate Euler’s totient \( \varphi(n) = (p-1)(q-1) \), the count of integers coprime to \( n \).</li>
                <li>Select a public exponent \( e \), often a small prime like 3 or 65537, where \( 1 < e < \varphi(n) \) and \( \gcd(e, \varphi(n)) = 1 \).</li>
                <li>Compute the private key \( d \), the modular inverse of \( e \), such that \( e \cdot d \equiv 1 \pmod{\varphi(n)} \), using the extended Euclidean algorithm.</li>
            </ol>
            <p class="mt-2 text-gray-700 leading-relaxed">
                The public key is the pair \( (n, e) \), used for encryption, while the private key \( d \) is used for decryption. Encryption transforms the message \( M \) into ciphertext:
                \[
                C = M^e \mod n
                \]
                Decryption recovers the original message:
                \[
                M = C^d \mod n
                \]
                These operations use modular exponentiation, computed efficiently via the square-and-multiply algorithm to handle large numbers.
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Why It Works</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                The security of RSA hinges on Euler’s theorem and the difficulty of factoring \( n \). Euler’s theorem states that for \( \gcd(M, n) = 1 \), \( M^{\varphi(n)} \equiv 1 \pmod{n} \). Since \( e \cdot d \equiv 1 \pmod{\varphi(n)} \), we can write \( ed = 1 + k \varphi(n) \) for some integer \( k \). Thus:
                \[
                (M^e)^d = M^{ed} = M^{1 + k \varphi(n)} = M \cdot (M^{\varphi(n)})^k \equiv M \cdot 1^k \equiv M \pmod{n}
                \]
                This ensures the decrypted message matches the original. For cases where \( \gcd(M, n) \neq 1 \), the Chinese Remainder Theorem (CRT) guarantees correct decryption by solving the system modulo \( p \) and \( q \).
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Enhancing Security with Padding</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                Direct RSA encryption is deterministic, meaning the same message always produces the same ciphertext, which can be vulnerable to attacks like chosen-plaintext attacks. To mitigate this, RSA is typically used with padding schemes like Optimal Asymmetric Encryption Padding (OAEP). OAEP adds randomness to the message before encryption:
            </p>
            <ul class="list-disc ml-6 mt-2 text-gray-700">
                <li>Combine the message \( M \) with a random seed \( r \) using a hash function \( G \): \( \text{maskedMsg} = M \oplus G(r) \).</li>
                <li>Mask the seed with another hash function \( H \): \( \text{maskedSeed} = r \oplus H(\text{maskedMsg}) \).</li>
                <li>Concatenate: \( M' = \text{maskedMsg} \,||\, \text{maskedSeed} \).</li>
                <li>Encrypt \( M' \) as \( C = (M')^e \mod n \).</li>
            </ul>
            <p class="mt-2 text-gray-700 leading-relaxed">
                OAEP ensures semantic security, making it computationally infeasible to distinguish ciphertexts without the private key. This is critical for real-world applications like secure email or online banking.
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Practical Considerations</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                In practice, RSA is computationally intensive due to large exponentiations, so it’s often used to encrypt small data, like symmetric keys for AES, in a hybrid encryption system. The security relies on the size of \( p \) and \( q \): modern systems use at least 2048-bit keys to resist factorization attacks, as advances in algorithms like the quadratic sieve or quantum computing could threaten smaller keys. Additionally, side-channel attacks, such as timing attacks, require countermeasures like constant-time exponentiation.
            </p>
            <div class="math-step">
                <strong>Security Note:</strong> The strength of RSA depends on the secrecy of \( d \) and the difficulty of factoring \( n \). Quantum computers, if scalable, could use Shor’s algorithm to factor \( n \) efficiently, prompting research into post-quantum cryptography like lattice-based systems.
            </div>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Real-World Applications</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                RSA is integral to secure communication protocols. For example:
            </p>
            <ul class="list-disc ml-6 mt-2 text-gray-700">
                <li><strong>HTTPS:</strong> RSA secures the initial handshake in TLS/SSL, encrypting session keys to protect web traffic.</li>
                <li><strong>Digital Signatures:</strong> RSA signs messages to verify authenticity, used in software updates and secure emails.</li>
                <li><strong>Secure Messaging:</strong> Apps like Signal use RSA for key exchange to ensure end-to-end encryption.</li>
            </ul>
            <p class="mt-2 text-gray-700 leading-relaxed">
                By combining discrete mathematics with practical implementation, RSA provides a robust framework for securing text-based communication in the digital age.
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Try It Yourself: RSA Text Encryption Simulator</h3>
            <div class="interactive-demo">
                <p class="text-gray-700 leading-relaxed">Enter a message to encrypt it step-by-step using RSA. Default primes are \( p=61 \), \( q=53 \), \( n=3233 \), with \( e=17 \), \( d=413 \). Adjust primes or block size as needed.</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="textProgressFill"></div>
                </div>
                <div class="step" id="textStep1">
                    <h2>Step 1: Enter Your Message</h2>
                    <div class="input-group">
                        <label for="messageInput">Message to encrypt:</label>
                        <input type="text" id="messageInput" placeholder="Hello World!" value="Hi!" aria-label="Message to encrypt">
                    </div>
                    <button onclick="textProcessMessage()" aria-label="Process message">Process Message</button>
                    <div id="charEncodingResult"></div>
                </div>
                <div class="step" id="textStep2">
                    <h2>Step 2: RSA Key Generation</h2>
                    <div class="grid">
                        <div>
                            <label for="textPrimeP">Prime p:</label>
                            <input type="number" id="textPrimeP" value="61" min="3" max="1000" aria-label="Prime number p">
                        </div>
                        <div>
                            <label for="textPrimeQ">Prime q:</label>
                            <input type="number" id="textPrimeQ" value="53" min="3" max="1000" aria-label="Prime number q">
                        </div>
                    </div>
                    <button onclick="textGenerateKeys()" aria-label="Generate RSA keys">Generate Keys</button>
                    <div id="keyGenerationResult"></div>
                </div>
                <div class="step" id="textStep3">
                    <h2>Step 3: Simplified OAEP Padding</h2>
                    <div class="input-group">
                        <label for="seedInput">Random Seed (0–255):</label>
                        <input type="number" id="seedInput" value="42" min="0" max="255" aria-label="Random seed">
                    </div>
                    <button onclick="textPadMessage()" aria-label="Apply padding">Apply Padding</button>
                    <div id="paddingResult"></div>
                </div>
                <div class="step" id="textStep4">
                    <h2>Step 4: Encryption</h2>
                    <button onclick="textEncryptMessage()" aria-label="Encrypt blocks">Encrypt Blocks</button>
                    <div id="encryptionResult"></div>
                </div>
                <div class="step" id="textStep5">
                    <h2>Step 5: Decryption</h2>
                    <button onclick="textDecryptMessage()" aria-label="Decrypt blocks">Decrypt Back to Text</button>
                    <div id="decryptionResult"></div>
                </div>
            </div>
        </section>

        <!-- Image Encryption -->
        <section id="image-encryption" class="my-12 card">
            <h2>Image Encryption with RSA</h2>
            <p class="mt-4 text-gray-700 leading-relaxed">
                Image encryption is vital for securing visual data, such as satellite imagery, medical scans, or personal photos transmitted over networks. RSA, with its foundation in number theory, transforms pixel data into unreadable ciphertext, ensuring confidentiality for sensitive applications like military reconnaissance or telemedicine.
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Turning Pixels into Numbers</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                An image is a grid of pixels, where each pixel is defined by its RGB (Red, Green, Blue) values, each ranging from 0 to 255:
                \[
                R_{i,j}, G_{i,j}, B_{i,j} \in \{0, 1, \dots, 255\}
                \]
                To encrypt with RSA, we combine the RGB values of a pixel into a single integer using base-256 encoding:
                \[
                M = R \cdot 256^2 + G \cdot 256 + B
                \]
                For example, a pixel with RGB values (100, 150, 200) is encoded as:
                \[
                M = 100 \cdot 65536 + 150 \cdot 256 + 200 = 6,592,200
                \]
                The resulting \( M \) must be less than the RSA modulus \( n \) to ensure correct encryption and decryption. This encoding is reversible, allowing the original RGB values to be recovered.
            </p>
            <div class="math-step">
                <strong>Why Base-256?</strong> Each RGB component fits within a byte (8 bits), making base-256 encoding efficient for packing pixel data into a single number suitable for RSA.
            </div>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">RSA Mechanics for Images</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                RSA key generation for image encryption follows the same process as for text:
            </p>
            <ol class="list-decimal ml-6 mt-2 text-gray-700">
                <li>Select two large primes \( p \) and \( q \), often much larger for images due to higher data volume.</li>
                <li>Compute \( n = p \cdot q \) and \( \varphi(n) = (p-1)(q-1) \).</li>
                <li>Choose a public exponent \( e \) such that \( 1 < e < \varphi(n) \) and \( \gcd(e, \varphi(n)) = 1 \).</li>
                <li>Compute the private key \( d \) where \( e \cdot d \equiv 1 \pmod{\varphi(n)} \).</li>
            </ol>
            <p class="mt-2 text-gray-700 leading-relaxed">
                Each pixel’s encoded value \( M \) is encrypted:
                \[
                C = M^e \mod n
                \]
                Decryption recovers \( M \):
                \[
                M = C^d \mod n
                \]
                The recovered \( M \) is then decoded back into RGB values by reversing the base-256 encoding.
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Enhancing Security with OAEP Padding</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                Direct RSA encryption of pixel values is deterministic, making it vulnerable to attacks like pattern analysis, especially in images with repetitive structures (e.g., a blue sky). Optimal Asymmetric Encryption Padding (OAEP) introduces randomness to mitigate this:
            </p>
            <ul class="list-disc ml-6 mt-2 text-gray-700">
                <li>Generate a random seed \( r \).</li>
                <li>Mask the message: \( \text{maskedMsg} = M \oplus G(r) \), where \( G \) is a hash function.</li>
                <li>Mask the seed: \( \text{maskedSeed} = r \oplus H(\text{maskedMsg}) \), where \( H \) is another hash function.</li>
                <li>Combine: \( M' = \text{maskedMsg} \,||\, \text{maskedSeed} \).</li>
                <li>Encrypt: \( C = (M')^e \mod n \).</li>
            </ul>
            <p class="mt-2 text-gray-700 leading-relaxed">
                During decryption, \( M' \) is recovered with \( M' = C^d \mod n \), and the padding is reversed to retrieve \( M \). OAEP ensures semantic security, making it computationally infeasible to deduce the original pixel values without the private key.
            </p>
            <div class="math-step">
                <strong>Why Padding Matters:</strong> In images, identical pixel values (e.g., in uniform areas) produce identical ciphertexts without padding, leaking structural information. OAEP randomizes each encryption, enhancing security.
            </div>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Challenges in Image Encryption</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                Encrypting images with RSA presents unique challenges due to the large volume of data:
            </p>
            <ul class="list-disc ml-6 mt-2 text-gray-700">
                <li><strong>Computational Overhead:</strong> Each pixel requires modular exponentiation, which is computationally intensive. For a 1920x1080 image, that’s over 2 million pixels, necessitating efficient algorithms or larger primes.</li>
                <li><strong>Key Size:</strong> The modulus \( n \) must be larger than the maximum pixel value (e.g., 256^3 = 16,777,216 for RGB). In practice, 2048-bit or larger keys are used to accommodate padding and ensure security.</li>
                <li><strong>Data Correlation:</strong> Images often have spatial correlations (e.g., adjacent pixels with similar colors). Encryption must disrupt these patterns to prevent attacks like statistical analysis.</li>
            </ul>
            <p class="mt-2 text-gray-700 leading-relaxed">
                To address these, RSA is often used in a hybrid system, encrypting a symmetric key (e.g., for AES) that then encrypts the image data more efficiently.
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Real-World Applications</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                Image encryption is critical in various domains:
            </p>
            <ul class="list-disc ml-6 mt-2 text-gray-700">
                <li><strong>Military and Surveillance:</strong> Encrypting satellite or drone imagery prevents adversaries from intercepting strategic data.</li>
                <li><strong>Medical Imaging:</strong> Protecting patient data in X-rays, MRIs, or telemedicine ensures compliance with regulations like HIPAA.</li>
                <li><strong>Digital Media:</strong> Securing copyrighted images or sensitive photographs during transmission over cloud services.</li>
                <li><strong>Biometric Security:</strong> Encrypting facial recognition or fingerprint images to prevent unauthorized access.</li>
            </ul>
            <p class="mt-2 text-gray-700 leading-relaxed">
                For example, in telemedicine, a doctor might transmit an encrypted MRI scan to a specialist. RSA ensures the data remains confidential, even over unsecured networks.
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Security Considerations</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                RSA’s security for images relies on the same principles as for text, but additional factors apply:
            </p>
            <ul class="list-disc ml-6 mt-2 text-gray-700">
                <li><strong>Large Primes:</strong> Images require larger \( p \) and \( q \) to handle higher numerical values and padding overhead, increasing computational cost but enhancing security.</li>
                <li><strong>Side-Channel Attacks:</strong> Timing or power analysis attacks can exploit pixel processing patterns, requiring countermeasures like randomized padding or constant-time operations.</li>
                <li><strong>Post-Quantum Threats:</strong> Quantum algorithms like Shor’s could factor \( n \), necessitating exploration of post-quantum alternatives like lattice-based cryptography for future-proofing.</li>
            </ul>
            <div class="math-step">
                <strong>Performance Tip:</strong> The Chinese Remainder Theorem (CRT) can optimize decryption by computing \( M_p = C^{d_p} \pmod{p} \) and \( M_q = C^{d_q} \pmod{q} \), then combining results, reducing computation time for large images.
            </div>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Hybrid Encryption for Images</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                Due to RSA’s computational intensity, hybrid encryption is common for images. RSA encrypts a symmetric key (e.g., a 256-bit AES key), which then encrypts the pixel data:
            </p>
            <ol class="list-decimal ml-6 mt-2 text-gray-700">
                <li>Generate a random AES key \( K \).</li>
                <li>Use RSA to encrypt \( K \): \( C_K = K^e \mod n \).</li>
                <li>Encrypt pixel data with AES using \( K \), leveraging AES’s efficiency in \( \mathbb{F}_{2^8} \).</li>
                <li>Transmit \( C_K \) and the AES-encrypted image.</li>
                <li>The receiver decrypts \( K \) with RSA, then uses \( K \) to decrypt the image with AES.</li>
            </ol>
            <p class="mt-2 text-gray-700 leading-relaxed">
                This approach combines RSA’s secure key exchange with AES’s fast bulk encryption, ideal for large images.
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Try It Yourself: RSA Image Encryption Simulator</h3>
            <div class="interactive-demo">
                <p class="text-gray-700 leading-relaxed">Upload an image (PNG/JPEG) to encrypt and decrypt its pixels using RSA. Use default primes p=65537, q=65539 for larger images. <strong>Note: Large images may take a long time to process due to RSA’s computational intensity.</strong></p>
                <div class="progress-bar">
                    <div class="progress-fill" id="imageProgressFill"></div>
                </div>
                <div class="step" id="imageStep1">
                    <h2>Step 1: Upload Your Image</h2>
                    <div class="input-group">
                        <label for="imageInput">Select Image (PNG/JPEG):</label>
                        <input type="file" id="imageInput" accept="image/png,image/jpeg" aria-label="Upload image">
                    </div>
                    <button onclick="imageProcessImage()" aria-label="Process image">Process Image</button>
                    <div id="imageDisplay" class="canvas-container"></div>
                    <div id="pixelEncodingResult"></div>
                </div>
                <div class="step" id="imageStep2">
                    <h2>Step 2: RSA Key Generation</h2>
                    <div class="grid">
                        <div>
                            <label for="imagePrimeP">Prime p:</label>
                            <input type="number" id="imagePrimeP" value="65537" min="3" max="1000000" aria-label="Prime number p">
                        </div>
                        <div>
                            <label for="imagePrimeQ">Prime q:</label>
                            <input type="number" id="imagePrimeQ" value="65539" min="3" max="1000000" aria-label="Prime number q">
                        </div>
                    </div>
                    <button onclick="imageGenerateKeys()" aria-label="Generate RSA keys for image">Generate Keys</button>
                    <div id="imageKeyGenerationResult"></div>
                </div>
                <div class="step" id="imageStep3">
                    <h2>Step 3: Simplified OAEP Padding</h2>
                    <div class="input-group">
                        <label for="seedInput">Random Seed (0–255):</label>
                        <input type="number" id="seedInput" value="42" min="0" max="255" aria-label="Random seed">
                    </div>
                    <button onclick="imagePadImage()" aria-label="Apply padding">Apply Padding</button>
                    <div id="paddingResult"></div>
                </div>
                <div class="step" id="imageStep4">
                    <h2>Step 4: Encryption</h2>
                    <button onclick="imageEncryptImage()" aria-label="Encrypt image">Encrypt Image</button>
                    <div id="imageEncryptionResult"></div>
                </div>
                <div class="step" id="imageStep5">
                    <h2>Step 5: Decryption and Verification</h2>
                    <button onclick="imageDecryptImage()" aria-label="Decrypt image">Decrypt and Verify</button>
                    <div id="imageDecryptionResult"></div>
                    <div id="decryptedImageDisplay" class="canvas-container"></div>
                </div>
            </div>
        </section>

        <!-- Video Encryption -->
        <section id="video-encryption" class="my-12 card">
            <h2>Video Encryption with RSA and AES</h2>
            <p class="mt-4 text-gray-700 leading-relaxed">
                Videos, as sequences of image frames, are critical in applications like military intelligence and secure communications. A hybrid approach combining RSA for secure key exchange and AES for efficient frame encryption ensures privacy and authenticity.
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">What Is a Video Mathematically?</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                A video is a sequence of frames:
                \[
                \text{Video} = \{F_1, F_2, \dots, F_T\}
                \]
                Each frame \( F_t \) is an \( H \times W \) matrix of pixels, with RGB values in \( \mathbb{Z}_{256} \).
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">From Pixels to Numbers</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                Pixel RGB values are packed into integers:
                \[
                M_{i,j} = R_{i,j} \cdot 256^2 + G_{i,j} \cdot 256 + B_{i,j}
                \]
                Multiple pixels can be combined for efficiency:
                \[
                M = \sum_{t=1}^k p_t \cdot 256^{3(k-t)}
                \]
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">RSA: Secure Key Exchange</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                RSA encrypts a random AES key \( K \):
                \[
                C_K = K^e \pmod{n}
                \]
                The receiver decrypts using the private key \( d \).
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">AES: Fast Frame Encryption</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                AES encrypts frames in \( \mathbb{F}_{2^8} \), using SubBytes, ShiftRows, MixColumns, and AddRoundKey operations to achieve confusion and diffusion.
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Digital Signatures and Hash Chains</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                Digital signatures use RSA to sign frame hashes:
                \[
                S_t = H(F_t)^d \pmod{n}
                \]
                Hash chains link frames:
                \[
                H_0 = H(F_0), \quad H_t = H(F_t \parallel H_{t-1})
                \]
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Real-World Applications</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                This secures drone surveillance, medical imaging, and corporate communications.
            </p>
        </section>

        <!-- Advanced Mathematical Constructions -->
        <section id="advanced-constructions" class="my-12 card">
            <h2>Advanced Mathematical Constructions</h2>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Extended Euclidean Algorithm</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                Finds \( d \) such that \( e \cdot d \equiv 1 \pmod{\varphi(n)} \):
                \[
                ax + by = \gcd(a,b)
                \]
            </p>
            <pre class="result">
ExtendedGCD(e, φ(n)):
    if φ(n) = 0:
        return (e, 1, 0)
    else:
        (gcd, x1, y1) = ExtendedGCD(φ(n), e mod φ(n))
        x = y1
        y = x1 - (e ÷ φ(n)) × y1
        return (gcd, x, y)
            </pre>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">Chinese Remainder Theorem</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                Speeds up RSA decryption:
                \[
                M_p = C^{d_p} \pmod{p}, \quad M_q = C^{d_q} \pmod{q}
                \]
                \[
                M = M_p \cdot q \cdot (q^{-1} \bmod{p}) + M_q \cdot p \cdot (p^{-1} \bmod{q}) \pmod{n}
                \]
            </h3>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">AES Finite Field</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                AES uses \( \mathbb{F}_{2^8} \), with polynomial arithmetic modulo \( x^8 + x^4 + x^3 + x + 1 \).
            </p>
            <h3 class="text-2xl font-medium mt-6 text-blue-800">SHA-256 Hash</h3>
            <p class="mt-2 text-gray-700 leading-relaxed">
                SHA-256 processes 512-bit blocks with 64 rounds, ensuring preimage and collision resistance.
            </p>
        </section>

        <!-- Conclusion -->
        <section id="conclusion" class="my-12 card">
            <h2>Conclusion</h2>
            <p class="mt-4 text-gray-700 leading-relaxed">
                Discrete mathematics powers modern cryptography, securing text, images, and videos. RSA leverages prime factorization and Euler’s theorem, while AES uses finite fields for efficiency. Hybrid encryption and digital signatures ensure security and authenticity, protecting critical communications from military to medical applications.
            </p>
            <p class="mt-4 text-gray-600 text-sm">
                © All rights reserved. Authored by Kaushik. Contact: kaushik.kaushik@iitgn.ac.in
            </p>
        </section>
    </main>

    <script>
        // Shared utility functions
        function modPow(base, exp, mod) {
            base = BigInt(base);
            exp = BigInt(exp);
            mod = BigInt(mod);
            let result = 1n;
            base = base % mod;
            while (exp > 0n) {
                if (exp & 1n) result = (result * base) % mod;
                base = (base * base) % mod;
                exp >>= 1n;
            }
            return result;
        }

        function isPrime(num) {
            num = Number(num);
            if (num < 2) return false;
            for (let i = 2; i <= Math.sqrt(num); i++) {
                if (num % i === 0) return false;
            }
            return true;
        }

        function gcd(a, b) {
            a = Number(a);
            b = Number(b);
            while (b !== 0) {
                let temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }

        function modInverse(e, phi) {
            e = Number(e);
            phi = Number(phi);
            let [old_r, r] = [e, phi];
            let [old_s, s] = [1, 0];
            while (r !== 0) {
                let quotient = Math.floor(old_r / r);
                [old_r, r] = [r, old_r - quotient * r];
                [old_s, s] = [s, old_s - quotient * s];
            }
            return old_s < 0 ? old_s + phi : old_s;
        }

        function simpleHash(input) {
            let hash = 0;
            const str = input.toString();
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash + str.charCodeAt(i)) & 0x7fffffff;
            }
            return hash % 256;
        }

        // Text Encryption Simulator
        let textState = {
            message: '',
            charCodes: [],
            p: 61,
            q: 53,
            n: 0,
            phi: 0,
            e: 17,
            d: 0,
            blocks: [],
            seed: 0,
            paddedBlocks: [],
            encryptedBlocks: [],
            blockSize: 2
        };

        function textUpdateProgress(step) {
            const progress = (step / 5) * 100;
            document.getElementById('textProgressFill').style.width = progress + '%';
        }

        function textProcessMessage() {
            const message = document.getElementById('messageInput').value;
            if (!message) {
                alert('Please enter a message!');
                return;
            }
            textState.message = message;
            textState.charCodes = [];
            let resultHTML = '<h3>Character Encoding (ASCII):</h3>';
            resultHTML += '<div class="char-encoding">';
            for (let i = 0; i < message.length; i++) {
                const char = message[i];
                const code = char.charCodeAt(0);
                textState.charCodes.push(code);
                resultHTML += `<div class="char-box">'${char}' → ${code}</div>`;
            }
            resultHTML += '</div>';
            resultHTML += `<div class="result">ASCII codes: [${textState.charCodes.join(', ')}]</div>`;
            document.getElementById('charEncodingResult').innerHTML = resultHTML;
            textUpdateProgress(1);
        }

        function textGenerateKeys() {
            const p = parseInt(document.getElementById('textPrimeP').value);
            const q = parseInt(document.getElementById('textPrimeQ').value);
            if (!isPrime(p) || !isPrime(q)) {
                alert('Both p and q must be prime numbers!');
                return;
            }
            if (p === q) {
                alert('p and q must be different primes!');
                return;
            }
            textState.p = p;
            textState.q = q;
            textState.n = p * q;
            textState.phi = (p - 1) * (q - 1);
            let e = 3;
            while (e < textState.phi && gcd(e, textState.phi) !== 1) {
                e += 2;
            }
            textState.e = e;
            textState.d = modInverse(e, textState.phi);
            let resultHTML = '<div class="math-step">';
            resultHTML += `<strong>Key Generation Steps:</strong><br>`;
            resultHTML += `1. Choose primes: p = ${p}, q = ${q}<br>`;
            resultHTML += `2. Calculate n = p × q = ${p} × ${q} = ${textState.n}<br>`;
            resultHTML += `3. Calculate φ(n) = (p-1)(q-1) = ${p-1} × ${q-1} = ${textState.phi}<br>`;
            resultHTML += `4. Choose e = ${e} (gcd(${e}, ${textState.phi}) = 1)<br>`;
            resultHTML += `5. Calculate d ≡ e⁻¹ (mod φ(n)): d = ${textState.d}<br>`;
            resultHTML += `6. Verify: e × d = ${e} × ${textState.d} = ${e * textState.d} ≡ 1 (mod ${textState.phi})<br>`;
            resultHTML += '</div>';
            resultHTML += `<div class="result success">`;
            resultHTML += `<strong>🔑 Generated Keys:</strong><br>`;
            resultHTML += `Public Key: (n=${textState.n}, e=${textState.e})<br>`;
            resultHTML += `Private Key: d=${textState.d}`;
            resultHTML += `</div>`;
            document.getElementById('keyGenerationResult').innerHTML = resultHTML;
            textUpdateProgress(2);
        }

        function textPadMessage() {
            if (textState.charCodes.length === 0) {
                document.getElementById('paddingResult').innerHTML = `<div class="result warning">⚠️ Please process a message first!</div>`;
                return;
            }
            const k = parseInt(document.getElementById('blockSize').value);
            const seed = parseInt(document.getElementById('seedInput').value);
            if (seed < 0 || seed > 255) {
                document.getElementById('paddingResult').innerHTML = `<div class="result warning">⚠️ Seed must be between 0 and 255!</div>`;
                return;
            }
            textState.blockSize = k;
            textState.seed = seed;
            textState.blocks = [];
            textState.paddedBlocks = [];
            let resultHTML = '<h3>Block Formation and Simplified OAEP Padding:</h3>';
            resultHTML += `<div class="math-step">Block Formation: M = c₁×256^(k-1) + c₂×256^(k-2) + ... + cₖ×256⁰</div>`;
            resultHTML += `<div class="math-step">Simplified OAEP: maskedMsg = M ⊕ G(seed), maskedSeed = seed ⊕ H(maskedMsg), M' = maskedMsg || maskedSeed</div>`;
            for (let i = 0; i < textState.charCodes.length; i += k) {
                let blockChars = textState.charCodes.slice(i, i + k);
                let M = 0n;
                let calculation = '';
                for (let j = 0; j < blockChars.length; j++) {
                    const power = blockChars.length - 1 - j;
                    const term = BigInt(blockChars[j]) * (256n ** BigInt(power));
                    M += term;
                    if (j > 0) calculation += ' + ';
                    calculation += `${blockChars[j]}×256^${power}`;
                }
                if (M >= BigInt(textState.n)) {
                    resultHTML += `<div class="warning">⚠️ Block ${M} ≥ n (${textState.n}). Try smaller block size or different primes!</div>`;
                    document.getElementById('paddingResult').innerHTML = resultHTML;
                    return;
                }
                const M_num = Number(M);
                const maskedMsg = M_num ^ simpleHash(seed);
                const maskedSeed = seed ^ simpleHash(maskedMsg);
                const paddedValue = (maskedMsg << 8) | maskedSeed;
                if (paddedValue >= textState.n) {
                    resultHTML += `<div class="warning">⚠️ Padded value ${paddedValue} ≥ n (${textState.n}). Try larger primes!</div>`;
                    document.getElementById('paddingResult').innerHTML = resultHTML;
                    return;
                }
                textState.blocks.push(M_num);
                textState.paddedBlocks.push(paddedValue);
                resultHTML += `<div class="result">`;
                resultHTML += `Block ${Math.floor(i/k) + 1}: [${blockChars.join(', ')}] → ${calculation} = ${M}<br>`;
                resultHTML += `Padding: M=${M_num}, maskedMsg=${maskedMsg}, maskedSeed=${maskedSeed}, M'=${paddedValue}<br>`;
                resultHTML += `</div>`;
            }
            resultHTML += `<div class="result success">✅ Formed and padded ${textState.paddedBlocks.length} blocks</div>`;
            document.getElementById('paddingResult').innerHTML = resultHTML;
            textUpdateProgress(3);
        }

        function textEncryptMessage() {
            if (textState.paddedBlocks.length === 0) {
                document.getElementById('encryptionResult').innerHTML = `<div class="result warning">⚠️ Please apply padding first!</div>`;
                return;
            }
            textState.encryptedBlocks = [];
            let resultHTML = '<h3>Encrypting Each Block:</h3>';
            resultHTML += `<div class="math-step">Encryption: C = (M')^${textState.e} mod ${textState.n}</div>`;
            for (let i = 0; i < textState.paddedBlocks.length; i++) {
                const M_prime = textState.paddedBlocks[i];
                const C = modPow(M_prime, textState.e, textState.n);
                textState.encryptedBlocks.push(Number(C));
                resultHTML += `<div class="result">`;
                resultHTML += `Block ${i + 1}: ${M_prime}^${textState.e} mod ${textState.n} = ${C}<br>`;
                resultHTML += `</div>`;
            }
            resultHTML += `<div class="result success">`;
            resultHTML += `<strong>🔒 Encrypted Message:</strong><br>`;
            resultHTML += `[${textState.encryptedBlocks.join(', ')}]`;
            resultHTML += `</div>`;
            document.getElementById('encryptionResult').innerHTML = resultHTML;
            textUpdateProgress(4);
        }

        function textDecryptMessage() {
            if (textState.encryptedBlocks.length === 0) {
                alert('Please encrypt the blocks first!');
                return;
            }
            let resultHTML = '<h3>Decrypting Each Block:</h3>';
            resultHTML += `<div class="math-step">Decryption: M' = C^${textState.d} mod ${textState.n}, then unpad to recover M</div>`;
            let decryptedBlocks = [];
            for (let i = 0; i < textState.encryptedBlocks.length; i++) {
                const C = textState.encryptedBlocks[i];
                const M_prime = modPow(C, textState.d, textState.n);
                const maskedMsg = Number(M_prime) >> 8;
                const maskedSeed = Number(M_prime) & 0xFF;
                const seed = maskedSeed ^ simpleHash(maskedMsg);
                const M = maskedMsg ^ simpleHash(seed);
                decryptedBlocks.push(M);
                resultHTML += `<div class="result">`;
                resultHTML += `Block ${i + 1}: ${C}^${textState.d} mod ${textState.n} = ${M_prime}<br>`;
                resultHTML += `Unpadding: maskedMsg=${maskedMsg}, maskedSeed=${maskedSeed}, seed=${seed}, M=${M}<br>`;
                resultHTML += `</div>`;
            }
            let decryptedText = '';
            for (let i = 0; i < decryptedBlocks.length; i++) {
                let blockValue = decryptedBlocks[i];
                let chars = '';
                for (let j = textState.blockSize - 1; j >= 0; j--) {
                    let charCode = blockValue % 256;
                    chars = String.fromCharCode(charCode) + chars;
                    blockValue = Math.floor(blockValue / 256);
                }
                decryptedText += chars;
            }
            resultHTML += `<div class="result success">`;
            resultHTML += `<strong>🔓 Decrypted Message:</strong><br>`;
            resultHTML += `${decryptedText}`;
            resultHTML += `</div>`;
            document.getElementById('decryptionResult').innerHTML = resultHTML;
            textUpdateProgress(5);
        }

        // Image Encryption Simulator
        let imageState = {
            originalImage: null,
            pixels: [],
            pixelValues: [],
            p: 65537,
            q: 65539,
            n: 0,
            phi: 0,
            e: 17,
            d: 0,
            seed: 0,
            paddedValues: [],
            ciphertexts: [],
            decryptedPixels: [],
            width: 0,
            height: 0
        };

        function imageUpdateProgress(step) {
            const progress = (step / 5) * 100;
            document.getElementById('imageProgressFill').style.width = progress + '%';
        }

        function imageProcessBatch(array, processFn, resultContainer, completionFn, batchSize = 50) {
            let index = 0;
            const total = array.length;
            resultContainer.innerHTML = `<div class="result">Processing ${total} pixels... <span id="progressText">0%</span></div>`;
            const progressText = document.getElementById('progressText');

            function processNextBatch() {
                const end = Math.min(index + batchSize, total);
                try {
                    for (let i = index; i < end; i++) {
                        processFn(i);
                    }
                    index = end;
                    const progress = Math.round((index / total) * 100);
                    if (progressText) {
                        progressText.textContent = `${progress}%`;
                    }
                    if (index < total) {
                        setTimeout(processNextBatch, 0);
                    } else {
                        completionFn();
                    }
                } catch (e) {
                    resultContainer.innerHTML = `<div class="result warning">⚠️ Error: ${e.message}. Try a smaller image or larger primes (e.g., p=65537, q=65539).</div>`;
                }
            }
            processNextBatch();
        }

        function imageProcessImage() {
            const input = document.getElementById('imageInput');
            if (!input.files[0]) {
                document.getElementById('pixelEncodingResult').innerHTML = `<div class="result warning">⚠️ Please upload an image!</div>`;
                return;
            }
            const file = input.files[0];
            if (!file.type.startsWith('image/png') && !file.type.startsWith('image/jpeg')) {
                document.getElementById('pixelEncodingResult').innerHTML = `<div class="result warning">⚠️ Please upload a PNG or JPEG image!</div>`;
                return;
            }
            const img = new Image();
            img.onload = function() {
                const display = document.getElementById('imageDisplay');
                display.innerHTML = '';
                const canvas = document.createElement('canvas');
                imageState.width = img.width;
                imageState.height = img.height;
                canvas.width = img.width;
                canvas.height = img.height;
                canvas.style.width = Math.min(img.width, 100) + 'px';
                canvas.style.height = Math.min(img.height, 100) + 'px';
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, img.width, img.height);
                imageState.originalImage = ctx.getImageData(0, 0, img.width, img.height);
                imageState.pixels = [];
                imageState.pixelValues = [];
                const totalPixels = img.width * img.height;
                let resultHTML = '<h3>Pixel Encoding (Base-256):</h3>';
                resultHTML += `<div class="math-step">Formula: M = R*256^2 + G*256 + B</div>`;
                resultHTML += '<div class="pixel-encoding">';
                const displayLimit = Math.min(10, totalPixels);
                for (let i = 0; i < img.height; i++) {
                    for (let j = 0; j < img.width; j++) {
                        const idx = (i * img.width + j) * 4;
                        const r = imageState.originalImage.data[idx];
                        const g = imageState.originalImage.data[idx + 1];
                        const b = imageState.originalImage.data[idx + 2];
                        const M = r * 65536 + g * 256 + b;
                        imageState.pixels.push([r, g, b]);
                        imageState.pixelValues.push(M);
                        if (i * img.width + j < displayLimit) {
                            resultHTML += `<div class="pixel-box">Pixel (${i},${j}): R=${r}, G=${g}, B=${b} → M=${M}</div>`;
                        }
                    }
                }
                if (totalPixels > displayLimit) {
                    resultHTML += `<div class="result">... Showing first ${displayLimit} of ${totalPixels} pixels</div>`;
                }
                resultHTML += '</div>';
                document.getElementById('pixelEncodingResult').innerHTML = resultHTML;
                display.innerHTML = '<span class="canvas-label">Uploaded Image:</span>';
                display.appendChild(canvas);
                imageUpdateProgress(1);
            };
            img.onerror = function() {
                document.getElementById('pixelEncodingResult').innerHTML = `<div class="result warning">⚠️ Failed to load image. Please try a different file.</div>`;
            };
            img.src = URL.createObjectURL(file);
        }

        function imageGenerateKeys() {
            const p = parseInt(document.getElementById('imagePrimeP').value);
            const q = parseInt(document.getElementById('imagePrimeQ').value);
            if (!isPrime(p) || !isPrime(q)) {
                document.getElementById('imageKeyGenerationResult').innerHTML = `<div class="result warning">⚠️ Both p and q must be prime numbers!</div>`;
                return;
            }
            if (p === q) {
                document.getElementById('imageKeyGenerationResult').innerHTML = `<div class="result warning">⚠️ p and q must be different primes!</div>`;
                return;
            }
            imageState.p = p;
            imageState.q = q;
            imageState.n = p * q;
            imageState.phi = (p - 1) * (q - 1);
            let e = 3;
            while (e < imageState.phi && gcd(e, imageState.phi) !== 1) {
                e += 2;
            }
            imageState.e = e;
            imageState.d = modInverse(e, imageState.phi);
            let resultHTML = '<div class="math-step">';
            resultHTML += `<strong>Key Generation Steps:</strong><br>`;
            resultHTML += `1. Choose primes: p = ${p}, q = ${q}<br>`;
            resultHTML += `2. Calculate n = p × q = ${p} × ${q} = ${imageState.n}<br>`;
            resultHTML += `3. Calculate φ(n) = (p-1)(q-1) = ${p-1} × ${q-1} = ${imageState.phi}<br>`;
            resultHTML += `4. Choose e = ${e} (gcd(${e}, ${imageState.phi}) = 1)<br>`;
            resultHTML += `5. Calculate d ≡ e⁻¹ (mod φ(n)): d = ${imageState.d}<br>`;
            resultHTML += `6. Verify: e × d = ${e} × ${imageState.d} = ${e * imageState.d} ≡ 1 (mod ${imageState.phi})<br>`;
            resultHTML += '</div>';
            resultHTML += `<div class="result success">`;
            resultHTML += `<strong>🔑 Generated Keys:</strong><br>`;
            resultHTML += `Public Key: (n=${imageState.n}, e=${imageState.e})<br>`;
            resultHTML += `Private Key: d=${imageState.d}`;
            resultHTML += `</div>`;
            document.getElementById('imageKeyGenerationResult').innerHTML = resultHTML;
            imageUpdateProgress(2);
        }

        function imagePadImage() {
            if (imageState.pixelValues.length === 0) {
                document.getElementById('paddingResult').innerHTML = `<div class="result warning">⚠️ Please process an image first!</div>`;
                return;
            }
            const seed = parseInt(document.getElementById('seedInput').value);
            if (seed < 0 || seed > 255) {
                document.getElementById('paddingResult').innerHTML = `<div class="result warning">⚠️ Seed must be between 0 and 255!</div>`;
                return;
            }
            imageState.seed = seed;
            imageState.paddedValues = [];
            const resultContainer = document.getElementById('paddingResult');
            resultContainer.innerHTML = '';
            imageProcessBatch(
                imageState.pixelValues,
                (i) => {
                    const M = imageState.pixelValues[i];
                    if (M >= imageState.n) {
                        throw new Error(`Pixel value ${M} ≥ n (${imageState.n}). Try larger primes.`);
                    }
                    const maskedMsg = M ^ simpleHash(seed);
                    const maskedSeed = seed ^ simpleHash(maskedMsg);
                    const paddedValue = (maskedMsg << 8) | maskedSeed;
                    imageState.paddedValues.push(paddedValue);
                },
                resultContainer,
                () => {
                    let resultHTML = `<div class="math-step">Simplified OAEP: maskedMsg = M ⊕ G(seed), maskedSeed = seed ⊕ H(maskedMsg), M' = maskedMsg || maskedSeed</div>`;
                    const displayLimit = Math.min(10, imageState.paddedValues.length);
                    for (let i = 0; i < displayLimit; i++) {
                        const M = imageState.pixelValues[i];
                        const maskedMsg = M ^ simpleHash(seed);
                        const maskedSeed = seed ^ simpleHash(maskedMsg);
                        const paddedValue = imageState.paddedValues[i];
                        resultHTML += `<div class="result">Pixel ${i}: M=${M}, maskedMsg=${maskedMsg}, maskedSeed=${maskedSeed}, M'=${paddedValue}</div>`;
                    }
                    if (imageState.paddedValues.length > displayLimit) {
                        resultHTML += `<div class="result">... Showing first ${displayLimit} of ${imageState.paddedValues.length} pixels</div>`;
                    }
                    resultHTML += `<div class="result success">✅ Padded ${imageState.paddedValues.length} pixels</div>`;
                    document.getElementById('paddingResult').innerHTML = resultHTML;
                    imageUpdateProgress(3);
                }
            );
        }

        function imageEncryptImage() {
            if (imageState.paddedValues.length === 0) {
                document.getElementById('imageEncryptionResult').innerHTML = `<div class="result warning">⚠️ Please apply padding first!</div>`;
                return;
            }
            if (imageState.n === 0) {
                document.getElementById('imageEncryptionResult').innerHTML = `<div class="result warning">⚠️ Please generate keys first!</div>`;
                return;
            }
            imageState.ciphertexts = [];
            const resultContainer = document.getElementById('imageEncryptionResult');
            resultContainer.innerHTML = '';
            imageProcessBatch(
                imageState.paddedValues,
                (i) => {
                    const paddedValue = imageState.paddedValues[i];
                    const C = modPow(paddedValue, imageState.e, imageState.n);
                    imageState.ciphertexts.push(Number(C));
                },
                resultContainer,
                () => {
                    let resultHTML = `<div class="math-step">Encryption: C = (M')^${imageState.e} mod ${imageState.n}</div>`;
                    const displayLimit = Math.min(10, imageState.ciphertexts.length);
                    for (let i = 0; i < displayLimit; i++) {
                        resultHTML += `<div class="result">Pixel ${i}: ${imageState.paddedValues[i]}^${imageState.e} mod ${imageState.n} = ${imageState.ciphertexts[i]}</div>`;
                    }
                    if (imageState.ciphertexts.length > displayLimit) {
                        resultHTML += `<div class="result">... Showing first ${displayLimit} of ${imageState.ciphertexts.length} ciphertexts</div>`;
                    }
                    resultHTML += `<div class="result success">🔒 Encrypted ${imageState.ciphertexts.length} pixels</div>`;
                    document.getElementById('imageEncryptionResult').innerHTML = resultHTML;
                    imageUpdateProgress(4);
                }
            );
        }

        function imageDecryptImage() {
            if (imageState.ciphertexts.length === 0) {
                document.getElementById('imageDecryptionResult').innerHTML = `<div class="result warning">⚠️ Please encrypt the image first!</div>`;
                return;
            }
            imageState.decryptedPixels = [];
            const resultContainer = document.getElementById('imageDecryptionResult');
            resultContainer.innerHTML = '';
            imageProcessBatch(
                imageState.ciphertexts,
                (i) => {
                    const C = imageState.ciphertexts[i];
                    const M_prime = modPow(C, imageState.d, imageState.n);
                    const maskedMsg = Number(M_prime) >> 8;
                    const maskedSeed = Number(M_prime) & 0xFF;
                    const seed = maskedSeed ^ simpleHash(maskedMsg);
                    const M = maskedMsg ^ simpleHash(seed);
                    const r = Math.floor(M / 65536);
                    const g = Math.floor(M / 256) % 256;
                    const b = M % 256;
                    imageState.decryptedPixels.push([r, g, b]);
                },
                resultContainer,
                () => {
                    let resultHTML = `<div class="math-step">Decryption: M' = C^${imageState.d} mod ${imageState.n}, then unpad to recover M</div>`;
                    const displayLimit = Math.min(10, imageState.decryptedPixels.length);
                    for (let i = 0; i < displayLimit; i++) {
                        const [r, g, b] = imageState.decryptedPixels[i];
                        resultHTML += `<div class="result">Pixel ${i}: R=${r}, G=${g}, B=${b}</div>`;
                    }
                    if (imageState.decryptedPixels.length > displayLimit) {
                        resultHTML += `<div class="result">... Showing first ${displayLimit} of ${imageState.decryptedPixels.length} pixels</div>`;
                    }
                    const canvas = document.createElement('canvas');
                    canvas.width = imageState.width;
                    canvas.height = imageState.height;
                    canvas.style.width = Math.min(imageState.width, 100) + 'px';
                    canvas.style.height = Math.min(imageState.height, 100) + 'px';
                    const ctx = canvas.getContext('2d');
                    const imageData = ctx.createImageData(imageState.width, imageState.height);
                    for (let i = 0; i < imageState.decryptedPixels.length; i++) {
                        const idx = i * 4;
                        imageData.data[idx] = imageState.decryptedPixels[i][0];
                        imageData.data[idx + 1] = imageState.decryptedPixels[i][1];
                        imageData.data[idx + 2] = imageState.decryptedPixels[i][2];
                        imageData.data[idx + 3] = 255;
                    }
                    ctx.putImageData(imageData, 0, 0);
                    const display = document.getElementById('decryptedImageDisplay');
                    display.innerHTML = '<span class="canvas-label">Decrypted Image:</span>';
                    display.appendChild(canvas);
                    let isIdentical = true;
                    for (let i = 0; i < imageState.pixels.length; i++) {
                        const [r1, g1, b1] = imageState.pixels[i];
                        const [r2, g2, b2] = imageState.decryptedPixels[i];
                        if (r1 !== r2 || g1 !== g2 || b1 !== b2) {
                            isIdentical = false;
                            break;
                        }
                    }
                    resultHTML += `<div class="result success">🔓 Decrypted ${imageState.decryptedPixels.length} pixels. Image is ${isIdentical ? 'identical' : 'not identical'} to original.</div>`;
                    document.getElementById('imageDecryptionResult').innerHTML = resultHTML;
                    imageUpdateProgress(5);
                }
            );
        }
    </script>
</body>
</html>
